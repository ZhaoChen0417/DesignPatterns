单例模式顾名思义，就是在一个项目中，要确保一个类只能有一个实例，而且自行实例化并向整个系统提供这个实例。如何理解呢，既然要确保一个项目中只能有一个类的实例，那就必须要确保该类的构造器不能被随便调用（创建实例最本质还是通过构造器），所以必须将构造器私有化，确保外部不能通过构造器来创建该类的实例。但是构造器私有化之后，外部如果想用这个类的实例怎么办呢，因为此时系统中该类的实例一个都没有，都说了单例，你至少得给我一个吧，那现在外面创建不了，就只能让这个类自己创建自己的实例了呗（就和克隆模式思想差不多），这个变量是属于当前类的，就是类变量，创建完还不行，你光创建了别人还得提供给别人用，于是还得创建一个公共方法让外部调用，来返回这个实例。这个就是单例模式

单例模式实现分类

- 饿汉式
- 懒汉式
- 双重检查
- 静态内部类
- 枚举

其实最根本的分类是根据类的实例生成的时机来进行划分，分为饿汉式、懒汉式。饿汉式顾名思义就是很饥渴，这个类的实例随着类的加载就生成，即使这个实例现在用不到，懒汉式就是这个类的实例在被用到的时候才进行生成。

上面说了饿汉式就是类的实例随着类的加载而创建，所以就要想怎么样能让这个实例随着类的加载而创建，这里有两种方法，一种是使用静态变量，一种是使用静态代码块
而懒汉式是在调用的时候创建，所以正常想法是在public静态方法里面，当有线程调用该方式时，判断如果当前类的实例为null，就new一个返回即可。但是如果是在多线程情况下，就有可能发生问题。关键代码如下
```java
if(instance == null){
    //每个线程判断完到这都会卡一下（丢失cpu执行权）
    instance =  new Class;
  }
return instance;
```
如果是在单线程情况下，每个线程依次排队, 第一个线程判断为null，然后创建，接着返回，然后第二个线程进行判断不为null，然后直接返回实例。如果在多线程情况下，有可能发生这么一种情况，当线程1进行判断为null，所以进入if代码块中，这时候有可能由于各种原因（就像注释写的卡一下）导致线程1丢失cpu执行权，而拿到cpu执行权的线程2，又到这里进行判断，此时instance依然为空，也就是说在instance = new Class这行代码上面有两个线程。然后不管线程1，还是线程2拿到cpu执行权往下执行，就都会导致这个类产生了2个或多个实例，也就不符合单例模式的初衷了

所以以上的懒汉式实现单例模式并不是很完美，而出现问题的地方就是在于多线程情况下有可能有多个线程进入创建实例的方法中。而应对多线程的线程安全问题，自然而然就想到了锁（对共享资源进行加锁），在Java中有个关键字Synchronize可以对方法加锁，这样就能保证当线程到达获取类的实例方法时，保证只能有一个线程进入判断并创建实例，然后返回让并行变为串行

上面这种使用Synchronize关键字对方法上锁，看似能够很好的解决多线程并发问题，也能实现单例模式的初衷，当时当有大量的线程进行并发访问时，饿汉式能够以很快的效率就处理完这些请求，因为实例已经提前定义好，只需要直接返回即可，而通过使用Synchronize关键字实现的懒汉式，就无法做到快速响应，因为需要频繁的进行加锁、释放锁的过程。就比如，现在有3个线程通同时请求获取实例，对于饿汉式来说，3个请求依次调用方法返回实例对象即可，但是对于用过Synchronize关键字实现的懒汉式来说，三个线程需要在方法前面排好队，依次拿锁，判断，解锁，返回。三个线程都按照这样的流程执行，效率大大降低。最关键的一点是，当线程1没执行之前，该类的唯一实例没有产生，进行非空判断还可以理解，但是当线程1执行完毕，项目中已经有了类的唯一实例。此时后面的线程还是需要拿锁，然后进行非空判断，非常消耗性能。那我想可不可以把非空的判断放在加锁之前呢？先判断有没有唯一实例，没有在加锁执行。于是这就出现了以懒汉式为核心思想的通过双重检查实现的单例模式。代码如下
```java
private static volatile Singleton instance;

public static Singleton getInstance() {
        if (instance == null) {
            //①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                    //②
                }
            }
        }
        return instance;
    }
```
双重检查顾名思义就是进行两次非空判断，第一次非空判断主要是为了提高效率，当已经有线程进行实例的创建，后面的线程判断非空，直接返回就好。而Synchronize关键字修饰的代码块中的第二次判断。是为了确保只有一个线程创建实例，避免多个线程同时通过第一层检查，导致创建多个对象。可以这样想象，在项目启动时有3个线程同时访问该方法，这时线程1先通过第一层非空判断，正当准备往下执行获取锁时，cpu执行权丢失，线程2继续执行，此时项目中该类的实例还未创建，所以也通过第一层非空检查，这时就有2个线程在同步代码块前面排队，这时线程1重新获得cpu执行权往下执行，先进行非空判断，然后创建对象，返回。这时线程2获取到cpu执行权往下执行，进行非空判断，发现已经有了实例，便不往下执行返回即可。如果没有第二次非空检查。这时就会出现多个实例返回的情况。

到这可能感觉双重检查已经结束了，但是还会出现这种情况，就是线程1执行到②时，丢失cpu执行权（可能一直丢失），但是此时已经创建了类的实例，这个时候如果线程3获取到cpu执行权，他会首先进行第一次非空判断，这个时候线程3怎么知道线程1已经进行了类的实例化？这个时候就需要用volatile关键字修饰保存实例的实例变量，这样即使多个线程操作共享变量，其他线程能够立刻感知到。这样就能保证即使线程1在创建完实例后卡死，其他线程也不会通过第一层非空检验，充分提高了效率

通过上面的懒汉式的各种实现方式可以发现，懒汉式的特点就是不会随着类的加载而加载，并且是在想用的时候才会提供。可以发现这个和静态内部类的加载过程非常类似，并且静态内部类他是线程安全的（详见JVM）于是就可以通过静态内部类来实现懒汉式的单例模式。代码如下
```java
// 静态内部类完成
class Singleton {

    //构造器私有化
    private Singleton() {
    }

    //静态内部类，该类中有一个静态属性 Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }

    //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

最后就是通过Java提供的枚举类来实现单例模式，这也是常用的方式，原理同上，不再赘述
